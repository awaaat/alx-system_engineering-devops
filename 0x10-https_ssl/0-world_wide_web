#!/usr/bin/env bash
# Script Name: 0-world_wide_web
# Description: This Bash script queries DNS records for subdomains of a given domain
#              using the 'dig' command. It displays the record type and destination
#              for specified subdomains or a default set of subdomains.
# Purpose: To audit DNS configurations for subdomains as part of a system
#          administration task, ensuring correct DNS mappings for a domain.
# Usage: ./0-world_wide_web <domain> [subdomain]
#   - domain: The domain name to audit (e.g., example.com)
#   - subdomain: Optional specific subdomain to audit (e.g., www)
# Output: Prints lines in the format:
#         "The subdomain [SUB_DOMAIN] is a [RECORD_TYPE] record and points to [DESTINATION]"
# Requirements:
#   - Must use 'awk' for parsing DNS output
#   - Must include at least one Bash function
#   - Must handle both single domain and domain+subdomain inputs
#   - Must pass Shellcheck (version 0.3.7) without errors
#   - Ignores nonexistent subdomains (per project requirements)
# Author: [Your Name]
# Date: July 14, 2025

# Function: get_subdomain_info
# Description: Queries DNS information for a specific subdomain using 'dig',
#              extracts the record type and destination, and prints the result
#              in the required format.
# Arguments:
#   $1 - domain: The domain name (e.g., example.com)
#   $2 - subdomain: The subdomain to query (e.g., www)
# Returns: Prints the DNS information or nothing if no valid record is found
get_subdomain_info() {
    # Store arguments in local variables for clarity
    local domain="$1"        # The domain name (e.g., example.com)
    local subdomain="$2"     # The subdomain name (e.g., www)

    # Construct the full domain name (e.g., www.example.com)
    local full_domain="${subdomain}.${domain}"

    # Use 'dig' to query DNS records for the full domain
    # '+short' option makes output concise, showing only the answer
    # Example output for 'dig +short www.example.com': 93.184.216.34
    # If it's an A record, we expect an IP address
    # For other record types (e.g., CNAME), it might return a hostname
    local dig_output
    dig_output=$(dig +short "${full_domain}")

    # Check if dig returned any output (non-empty means a record exists)
    if [ -n "${dig_output}" ]; then
        # Since 'dig +short' doesn't tell us the record type, we need to query again
        # Use full 'dig' output and parse the ANSWER SECTION
        # Example full dig output:
        # ;; ANSWER SECTION:
        # www.example.com. 300 IN A 93.184.216.34
        local answer_line
        answer_line=$(dig "${full_domain}" | grep -A1 'ANSWER SECTION:' | tail -n1)

        # Extract record type and destination using 'awk'
        # Fields in answer_line:
        # $1: full domain (www.example.com.)
        # $2: TTL (300)
        # $3: class (IN)
        # $4: record type (A, CNAME, etc.)
        # $5: destination (IP or hostname)
        local record_type
        local destination
        record_type=$(echo "${answer_line}" | awk '{print $4}')
        destination=$(echo "${answer_line}" | awk '{print $5}')

        # Only print if both record_type and destination are non-empty
        # This ensures we don't print incomplete or invalid records
        if [ -n "${record_type}" ] && [ -n "${destination}" ]; then
            # Print in the exact format required
            echo "The subdomain ${subdomain} is a ${record_type} record and points to ${destination}"
        fi
    fi
    # If dig_output is empty, we silently return (per requirement to ignore nonexistent subdomains)
}

# Main Script Logic
# Description: Handles command-line arguments and calls get_subdomain_info
#              for the appropriate subdomains based on input.

# Check the number of command-line arguments
if [ "$#" -eq 1 ]; then
    # Only domain provided; check default subdomains in specified order
    domain="$1"

    # Define the list of subdomains to check (in exact order per requirements)
    subdomains=("www" "lb-01" "web-01" "web-02")

    # Loop through each subdomain and call the function
    for subdomain in "${subdomains[@]}"; do
        get_subdomain_info "${domain}" "${subdomain}"
    done

elif [ "$#" -eq 2 ]; then
    # Both domain and subdomain provided; check only the specified subdomain
    domain="$1"
    subdomain="$2"
    get_subdomain_info "${domain}" "${subdomain}"

else
    # Incorrect number of arguments; show usage and exit
    echo "Usage: $0 domain [subdomain]"
    exit 1
fi